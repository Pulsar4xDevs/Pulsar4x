using System;
using System.Collections;

namespace Pulsar4X.ECSLib
{
    public class AdjacencyList : CollectionBase
    {
        protected internal virtual void Add(EdgeToNeighbor e)
        {
            InnerList.Add(e);
        }

        public virtual EdgeToNeighbor this[int index]
        {
            get { return (EdgeToNeighbor)InnerList[index]; }
            set { InnerList[index] = value; }
        }
    }

    /// <summary>
    /// A pathfinding node.
    /// </summary>
    /// <remarks>
    /// A node consists of two jump points, in effect combining their positions on top of each other.
    /// It contains a list of "neighbor" nodes. Neighbors are any nodes that have jumppoints in the same system as the jumppoints in this node.
    /// </remarks>
    public class Node
    {
        public Entity JP1 { get; }
        public Entity JP2 { get; }

        public string Key { get; }
        /// <summary>
        /// Our key must be unique. Key is generated by JP1 and JP2 Guids.
        /// Reverse key is generated by JP2 and JP1 Guids. This makes sure 
        /// only one node represents the unique combination.
        /// </summary>
        public string ReverseKey { get; }

        public AdjacencyList Neighbors { get; }

        internal Node(Entity jp1, Entity jp2, AdjacencyList neighbors)
        {
            JP1 = jp1;
            JP2 = jp2;
            Neighbors = neighbors;
            Key = $"{JP1.Guid} - {JP2.Guid}";
            ReverseKey = $"{JP2.Guid} - {JP1.Guid}";
        }

        /// <summary>
        /// Adds a directed edge to this node.
        /// </summary>
        protected internal virtual void AddDirected(Node n, double weight)
        {
            AddDirected(new EdgeToNeighbor(n, weight));
        }

        /// <summary>
        /// Adds a directed edge to this node.
        /// </summary>
        /// <remarks>
        /// In Pulsar4X, the edge is the distance between jumppoints within a system,
        /// therefore it doesn't make sense to add a directed edge. However, this node is
        /// only responsible for maintaining its own edges, not the edges of other nodes.
        /// The graph itself can ensure both nodes add the edges.
        /// </remarks>
        protected internal virtual void AddDirected(EdgeToNeighbor e)
        {
            Neighbors.Add(e);
        }

        internal bool IsNeighbor(Node other, out double weight)
        {

            var JP1positionDB = JP1.GetDataBlob<PositionDB>();
            StarSystem JP1System = JP1positionDB?.System;
            var JP2positionDB = JP2.GetDataBlob<PositionDB>();
            StarSystem JP2System = JP2positionDB?.System;

            var otherJP1positionDB = other.JP1.GetDataBlob<PositionDB>();
            StarSystem otherJP1System = otherJP1positionDB?.System;
            var otherJP2positionDB = other.JP2.GetDataBlob<PositionDB>();
            StarSystem otherJP2System = otherJP2positionDB?.System;

            if (JP1System != null)
            {
                if (JP1System == otherJP1System)
                {
                    weight = JP1positionDB.GetDistanceTo(otherJP1positionDB);
                    return true;
                }
                if (JP1System == otherJP2System)
                {
                    weight = JP1positionDB.GetDistanceTo(otherJP2positionDB);
                    return true;
                }
            }

            if (JP2System != null)
            {
                if (JP2System == otherJP1System)
                {
                    weight = JP2positionDB.GetDistanceTo(otherJP1positionDB);
                    return true;
                }
                if (JP2System == otherJP2System)
                {
                    weight = JP2positionDB.GetDistanceTo(otherJP2positionDB);
                    return true;
                }
            }
            weight = 0;
            return false;
        }
    }

    /// <summary>
    /// A pathfinding edge.
    /// </summary>
    /// <remarks>
    /// In Pulsar4X, a pathfinding edge is owned by a node, and points to the other node. Its weight is the distance between the JumpPoints in the nodes.
    /// </remarks>
    public class EdgeToNeighbor
    {
        public Node Neighbor { get; }

        /// <summary>
        /// Weight of this edge. In Pulsar4x, this is the distance from one JP to another in-system.
        /// </summary>
        public double Weight { get; }

        public EdgeToNeighbor(Node neighbor, double weight)
        {
            Neighbor = neighbor;
            Weight = weight;
        }
    }

    /// <summary>
    /// Simple hashtable implementation of a NodeList.
    /// Hashtable will keep lookup time very fast with larger datasets.
    /// </summary>
    public class NodeList : IEnumerable
    {
        private readonly Hashtable _data = new Hashtable();
        
        public virtual void Add(Node n)
        {
            _data.Add(n.Key, n);
        }

        public virtual void Remove(Node n)
        {
            _data.Remove(n.Key);
        }

        public virtual bool ContainsKey(string key)
        {
            return _data.ContainsKey(key);
        }

        public virtual void Clear()
        {
            _data.Clear();
        }

        // Properties...
        public virtual Node this[string key] => (Node)_data[key];
        public virtual int Count => _data.Count;

        public IEnumerator GetEnumerator()
        {
            return _data.GetEnumerator();
        }
    }

    /// <summary>
    /// Graph manipulation for pathfinding.
    /// </summary>
    public class Graph
    {
        public virtual NodeList Nodes => _nodes;
        private readonly NodeList _nodes = new NodeList();
        
        public virtual void AddNode(Node n)
        {
            // Make sure this node is unique
            if (!Contains(n))
                _nodes.Add(n);
            else
                throw new ArgumentException($"There already exists a node in the graph with key {n.Key}");
        }

        public virtual void AddUndirectedEdge(Node u, Node v, double weight)
        {
            // Make sure u and v are Nodes in this graph
            if (Contains(u) && Contains(v))
            {
                // Add an edge from u -> v and from v -> u
                _nodes[u.Key].AddDirected(v, weight);
                _nodes[v.Key].AddDirected(u, weight);
            }
            else
                // one or both of the nodes were not found in the graph
                throw new ArgumentException("One or both of the nodes supplied were not members of the graph.");
        }

        public virtual bool Contains(Node n)
        {
            return Contains(n.Key) || Contains(n.ReverseKey);
        }

        private bool Contains(string key)
        {
            return _nodes.ContainsKey(key);
        }
    }
}
